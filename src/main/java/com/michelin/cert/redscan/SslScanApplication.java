/**
 * Michelin CERT 2020.
 */

package com.michelin.cert.redscan;

import com.michelin.cert.redscan.utils.datalake.DatalakeStorageException;
import com.michelin.cert.redscan.utils.models.HttpService;
import com.michelin.cert.redscan.utils.models.Vulnerability;
import com.michelin.cert.redscan.utils.system.OsCommandExecutor;
import com.michelin.cert.redscan.utils.system.StreamGobbler;
import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.logging.log4j.LogManager;
import org.json.JSONArray;
import org.json.JSONObject;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * RedScan scanner main class.
 *
 * @author Maxime ESCOURBIAC
 * @author Sylvain VAISSIER
 * @author Maxence SCHMITT
 */
@SpringBootApplication
public class SslScanApplication {

  //Only required if pushing data to queues
  private final RabbitTemplate rabbitTemplate;

  @Autowired
  private DatalakeConfig datalakeConfig;

  /**
   * Constructor to init rabbit template. Only required if pushing data to queues
   *
   * @param rabbitTemplate Rabbit template.
   */
  public SslScanApplication(RabbitTemplate rabbitTemplate) {
    this.rabbitTemplate = rabbitTemplate;
  }

  /**
   * RedScan Main methods.
   *
   * @param args Application arguments.
   */
  public static void main(String[] args) {
    SpringApplication.run(SslScanApplication.class, args);
  }

  /**
   * Sending Alert to the good channel.
   * @param message should be the name of the domain
   * @param vulnName should be the conernend vuln (TLS activated, heartbleed..)
   * @param sev The sevrity of the vuln (HIGH,MEDIUM,LOW,INFO)
   * @param vulnData The JSON objcet representign the vulnerbaility to upsert.
   */
  public void alarm(String message, String vulnName, int sev, JSONObject vulnData) {
    Vulnerability vuln = new Vulnerability(Vulnerability.generateId("redscan-sslscan", message, vulnName),
        sev,
        String.format("[%s] failed on SSL/TLS check on %s", message,vulnName),
        String.format("Unsecured https on [%s] with SSL test on [%s] : %s",message,vulnName,vulnData),
        message,
        "redscan-sslscan"
        );
    
    rabbitTemplate.convertAndSend(RabbitMqConfig.FANOUT_VULNERABILITIES_EXCHANGE_NAME, "", vuln.toJson());
  }
  /**
   * Building result from xml to json object.
   * @param filename The string bind to the output xml filename generated by the script
   * @param message The domain name, briefly told.
   * @return JSONObject The final object that will be upsert into elastic.
   */
  public JSONObject readXml(String filename, String message) {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    JSONObject result = new JSONObject();
    try {
      //Create XML Parser
      dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      DocumentBuilder db = dbf.newDocumentBuilder();
      Document doc = db.parse(new File(filename));
      doc.getDocumentElement().normalize();
      //Getting all checks on protocols.
      NodeList protocolNodes = doc.getElementsByTagName("protocol");
      JSONArray protocolList = new JSONArray();
      for (int temp = 0; temp < protocolNodes.getLength(); temp++) {
        Node node = protocolNodes.item(temp);
        Element el = (Element) node;
        JSONObject prot  = new JSONObject();
        prot.append("type", (String) el.getAttribute("type"));
        prot.append("version", (String) el.getAttribute("version"));
        prot.append("enabled", (String) el.getAttribute("enabled"));
        protocolList.put(prot);
        //Create vulnerability depending on case.
        if (el.getAttribute("type").equalsIgnoreCase("ssl") && el.getAttribute("enabled").equalsIgnoreCase("1")) {
          LogManager.getLogger(SslScanApplication.class).info(String.format("[VULNERABILITY] : %s", prot.toString()));
          alarm(message, "obs_prot", 1, prot);
        }
        if (el.getAttribute("type").equalsIgnoreCase("tls") && el.getAttribute("enabled").equalsIgnoreCase("1")) {
          if (el.getAttribute("version").equalsIgnoreCase("1.0") || el.getAttribute("version").equalsIgnoreCase("1.1")) {
            alarm(message, "bbs_prot_vers", 2, prot);
          }
        }
      }
      result.append("protocols", protocolList);
      //Getting Renegociation Security Feature Information.
      Element el = (Element) doc.getElementsByTagName("renegotiation").item(0);
      JSONObject negoc = new JSONObject();
      negoc.put("supported", el.getAttribute("supported"));
      negoc.put("secure", el.getAttribute("secure"));
      result.put("renegociation", negoc);
      //Getting Heartbleed Check Informations.
      NodeList heartbleed = doc.getElementsByTagName("heartbleed");
      JSONArray heartbleedArray  = new JSONArray();
      for (int temp = 0; temp < heartbleed.getLength();temp++) {
        Node hbNode = heartbleed.item(temp);
        Element hbEl = (Element) hbNode;
        JSONObject hbJson = new JSONObject();
        hbJson.put("ssl_version", hbEl.getAttribute("sslversion"));
        hbJson.put("vulnerable", hbEl.getAttribute("vulnerable"));
        //Creating Vulnerability for Heartbleed
        if (hbEl.getAttribute("vulnerable").equalsIgnoreCase("1")) {
          LogManager.getLogger(SslScanApplication.class).info(String.format("[VULNERABILITY] : %s", hbJson.toString()));
          alarm(message, "heartbleed", 1, hbJson);
        }
        heartbleedArray.put(hbJson);
      }
      result.put("heartbleed", heartbleedArray);
      //Getting the signature algorithm
      Element signEl = (Element) doc.getElementsByTagName("signature-algorithm").item(0);
      result.put("algo", signEl.getTextContent());
      Element pkEl = (Element) doc.getElementsByTagName("pk").item(0);
      JSONObject pkJson = new JSONObject();
      //Getting Key streght.
      pkJson.append("key_strenght", pkEl.getAttribute("bits"));
      result.append("key_strenght", pkJson);
      //Creating Vulnerability for weak cypher
      if (Integer.parseInt(pkEl.getAttribute("bits").toString()) < 2048) {
        LogManager.getLogger(SslScanApplication.class).info(String.format("[VULNERABILITY] : %s", pkJson.toString()));
        alarm(message, "weak_key", 3, pkJson);
      }
      //Getting if the certificate is self signed.
      Element selfsignedEl = (Element) doc.getElementsByTagName("self-signed").item(0);
      JSONObject selfsignedJson = new JSONObject();
      selfsignedJson.put("self_signed", selfsignedEl.getTextContent());
      if (selfsignedEl.getTextContent().equals("true")) {
        LogManager.getLogger(SslScanApplication.class).info(String.format("[VULNERABILITY] : %s", selfsignedJson.toString()));
        alarm(message, "autosigned", 4, selfsignedJson);
      }
      result.put("isSelfSigned", selfsignedJson);
      //Getting date element.
      Element dateEl = (Element) doc.getElementsByTagName("not-valid-after").item(0);
      JSONObject dateJson = new JSONObject();
      dateJson.put("endDate", dateEl.getTextContent());
      Element expiredEl = (Element) doc.getElementsByTagName("expired").item(0);
      dateJson.put("expired", expiredEl.getTextContent());
      //Converting Date Element.
      SimpleDateFormat dateFormatter = new SimpleDateFormat("MMM dd HH:mm:ss yyyy");
      Date endDate = dateFormatter.parse(dateEl.getTextContent());
      Date today = Calendar.getInstance().getTime();
      long diffinmillis  = Math.abs(endDate.getTime() - today.getTime());
      long diff = TimeUnit.DAYS.convert(diffinmillis, TimeUnit.MILLISECONDS);
      String diffString = Long.toString(diff);
      dateJson.put("remainingDays", diffString);
      //Check date element and create vulnerbaility accordingly.
      if ((diff < 8) || expiredEl.getTextContent().equals("true")) {
        LogManager.getLogger(SslScanApplication.class).info(String.format("[VULNERABILITY] : %s", dateJson.toString()));
        alarm(message, "cert_expired", 2, dateJson);
      }
      LogManager.getLogger(SslScanApplication.class).info(String.format("[DATE INFORMATION] : %s", dateJson.toString()));
      result.put("Certificate Date", dateJson);
            
    } catch (IOException | ParserConfigurationException | SAXException | ParseException ex) {
      LogManager.getLogger(SslScanApplication.class).error(String.format("%s exception : %s",ex.getClass().toString(), ex));
    } finally {
      if (!new File(filename).delete()) {
        LogManager.getLogger(SslScanApplication.class).error(String.format("temp file still here"));
      } else {
        LogManager.getLogger(SslScanApplication.class).error(String.format("File deleted"));
      }
    }
    return result;
    
  }
  /**
   * Message executor.
   *
   * @param message Message received.
   */
  @RabbitListener(queues = {RabbitMqConfig.QUEUE_HTTP_SERVICES})
  public void receiveMessage(String message) {
    HttpService serviceMessage = new HttpService(message);
    
    //Check that the host is SSL
    // For developping use if (true)
    //in prod : if (serviceMessage.isSsl()) {
    if (serviceMessage.isSsl()) {
      LogManager.getLogger(SslScanApplication.class).info(String.format("SSL Scan [HTTP_SERVICES] received order on  : %s on port %s", serviceMessage.getDomain(), serviceMessage.getPort()));
      OsCommandExecutor osCommandExecutor = new OsCommandExecutor();
      StreamGobbler streamGobbler = osCommandExecutor.execute(String.format("sslscan --xml=%s.xml %s", serviceMessage.getDomain(), serviceMessage.getDomain()));
      if (streamGobbler != null) {
        LogManager.getLogger(SslScanApplication.class).info(String.format("Ssslscan terminated with status : %d", streamGobbler.getExitStatus()));
        if (streamGobbler.getErrorOutputs() != null && streamGobbler.getErrorOutputs().length != 0) {
          for (Object o: streamGobbler.getErrorOutputs()) {
            String result = (String) o;
            LogManager.getLogger(SslScanApplication.class).error(String.format("SSL Scan [HTTP_SERVICE] encoutered error : %s", result));
          }
        }

      }
      try {
        JSONObject data = readXml(String.format("%s.xml", serviceMessage.getDomain()), serviceMessage.getDomain());
        if (data != null) {
          LogManager.getLogger(SslScanApplication.class).info(String.format("Pserting data : %s", data.toString()));
          datalakeConfig.upsertHttpServiceField(serviceMessage.getDomain(), serviceMessage.getPort(), "SSlScan", data);
        } else {
          LogManager.getLogger(SslScanApplication.class).error(String.format("Empty data..."));
        }
      } catch (DatalakeStorageException ex) {
        LogManager.getLogger(SslScanApplication.class).error(String.format("datalake storage Exception :  %", ex)); 
      }       
        
    } else {
      LogManager.getLogger(SslScanApplication.class).info(String.format(" %s on port %s is not an HTTPS SERVICE. SSL is not set.", serviceMessage.getDomain(), serviceMessage.getPort()));
    }
    
    
  }

}
